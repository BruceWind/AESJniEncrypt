/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.androidyuan.aesjni;

public class Sodium implements SodiumConstants {
  public static int sodium_init() {
    return SodiumJNI.sodium_init();
  }

  public static String sodium_version_string() {
    return SodiumJNI.sodium_version_string();
  }

  public static void randombytes_buf(byte[] buf, int size) {
    SodiumJNI.randombytes_buf(buf, size);
  }

  public static int randombytes_random() {
    return SodiumJNI.randombytes_random();
  }

  public static int randombytes_uniform(int upper_bound) {
    return SodiumJNI.randombytes_uniform(upper_bound);
  }

  public static int crypto_sign_keypair(byte[] pk, byte[] sk) {
    return SodiumJNI.crypto_sign_keypair(pk, sk);
  }

  public static int crypto_sign_seed_keypair(byte[] pk, byte[] sk, byte[] seed) {
    return SodiumJNI.crypto_sign_seed_keypair(pk, sk, seed);
  }

  public static int crypto_sign(byte[] sm, SWIGTYPE_p_unsigned_long_long smlem, byte[] m, long mlen, byte[] sk) {
    return SodiumJNI.crypto_sign(sm, SWIGTYPE_p_unsigned_long_long.getCPtr(smlem), m, mlen, sk);
  }

  public static int crypto_sign_open(byte[] m, SWIGTYPE_p_unsigned_long_long mlen, byte[] sm, long smlen, byte[] pk) {
    return SodiumJNI.crypto_sign_open(m, SWIGTYPE_p_unsigned_long_long.getCPtr(mlen), sm, smlen, pk);
  }

  public static int crypto_sign_detached(byte[] sig, SWIGTYPE_p_unsigned_long_long slen, byte[] m, long mlen, byte[] sk) {
    return SodiumJNI.crypto_sign_detached(sig, SWIGTYPE_p_unsigned_long_long.getCPtr(slen), m, mlen, sk);
  }

  public static int crypto_sign_ed25519_sk_to_curve25519(byte[] curve25519_sk, byte[] ed25519_sk) {
    return SodiumJNI.crypto_sign_ed25519_sk_to_curve25519(curve25519_sk, ed25519_sk);
  }

  public static int crypto_sign_ed25519_pk_to_curve25519(byte[] curve25519_pk, byte[] ed25519_pk) {
    return SodiumJNI.crypto_sign_ed25519_pk_to_curve25519(curve25519_pk, ed25519_pk);
  }

  public static int crypto_sign_verify_detached(byte[] sig, byte[] m, long mlen, byte[] pk) {
    return SodiumJNI.crypto_sign_verify_detached(sig, m, mlen, pk);
  }

  public static int crypto_sign_ed25519_sk_to_seed(byte[] seed, byte[] sk) {
    return SodiumJNI.crypto_sign_ed25519_sk_to_seed(seed, sk);
  }

  public static int crypto_sign_ed25519_sk_to_pk(byte[] pk, byte[] sk) {
    return SodiumJNI.crypto_sign_ed25519_sk_to_pk(pk, sk);
  }

  public static int crypto_box_seed_keypair(byte[] pk, byte[] sk, byte[] seed) {
    return SodiumJNI.crypto_box_seed_keypair(pk, sk, seed);
  }

  public static int crypto_box_keypair(byte[] pk, byte[] sk) {
    return SodiumJNI.crypto_box_keypair(pk, sk);
  }

  public static int crypto_box_easy(byte[] c, byte[] m, long mlen, byte[] n, byte[] pk, byte[] sk) {
    return SodiumJNI.crypto_box_easy(c, m, mlen, n, pk, sk);
  }

  public static int crypto_box_open_easy(byte[] m, byte[] c, long clen, byte[] n, byte[] pk, byte[] sk) {
    return SodiumJNI.crypto_box_open_easy(m, c, clen, n, pk, sk);
  }

  public static int crypto_box_detached(byte[] c, byte[] mac, byte[] m, long mlen, byte[] n, byte[] pk, byte[] sk) {
    return SodiumJNI.crypto_box_detached(c, mac, m, mlen, n, pk, sk);
  }

  public static int crypto_box_open_detached(byte[] m, byte[] c, byte[] mac, long clen, byte[] n, byte[] pk, byte[] sk) {
    return SodiumJNI.crypto_box_open_detached(m, c, mac, clen, n, pk, sk);
  }

  public static int crypto_secretbox_easy(byte[] c, byte[] m, long mlen, byte[] n, byte[] k) {
    return SodiumJNI.crypto_secretbox_easy(c, m, mlen, n, k);
  }

  public static int crypto_secretbox_open_easy(byte[] m, byte[] c, long clen, byte[] n, byte[] k) {
    return SodiumJNI.crypto_secretbox_open_easy(m, c, clen, n, k);
  }

  public static int crypto_secretbox_detached(byte[] c, byte[] mac, byte[] m, long mlen, byte[] n, byte[] k) {
    return SodiumJNI.crypto_secretbox_detached(c, mac, m, mlen, n, k);
  }

  public static int crypto_secretbox_open_detached(byte[] m, byte[] c, byte[] mac, long clen, byte[] n, byte[] k) {
    return SodiumJNI.crypto_secretbox_open_detached(m, c, mac, clen, n, k);
  }

  public static int crypto_auth(byte[] out, byte[] in, long inlen, byte[] k) {
    return SodiumJNI.crypto_auth(out, in, inlen, k);
  }

  public static int crypto_auth_verify(byte[] h, byte[] in, long inlen, byte[] k) {
    return SodiumJNI.crypto_auth_verify(h, in, inlen, k);
  }

  public static int crypto_aead_chacha20poly1305_encrypt(byte[] c, SWIGTYPE_p_unsigned_long_long clen, byte[] m, long mlen, byte[] ad, long adlen, byte[] nsec, byte[] npub, byte[] k) {
    return SodiumJNI.crypto_aead_chacha20poly1305_encrypt(c, SWIGTYPE_p_unsigned_long_long.getCPtr(clen), m, mlen, ad, adlen, nsec, npub, k);
  }

  public static int crypto_aead_chacha20poly1305_decrypt(byte[] m, SWIGTYPE_p_unsigned_long_long mlen, byte[] nsec, byte[] c, long clen, byte[] ad, long adlen, byte[] npub, byte[] k) {
    return SodiumJNI.crypto_aead_chacha20poly1305_decrypt(m, SWIGTYPE_p_unsigned_long_long.getCPtr(mlen), nsec, c, clen, ad, adlen, npub, k);
  }

  public static int crypto_pwhash_scryptsalsa208sha256(byte[] out, long outlen, String passwd, long passwdlen, byte[] salt, long opslimit, int memlimit) {
    return SodiumJNI.crypto_pwhash_scryptsalsa208sha256(out, outlen, passwd, passwdlen, salt, opslimit, memlimit);
  }

  public static int crypto_pwhash_scryptsalsa208sha256_str(byte[] out, String passwd, long passwdlen, long opslimit, int memlimit) {
    return SodiumJNI.crypto_pwhash_scryptsalsa208sha256_str(out, passwd, passwdlen, opslimit, memlimit);
  }

  public static int crypto_pwhash_scryptsalsa208sha256_str_verify(byte[] str, String passwd, long passwdlen) {
    return SodiumJNI.crypto_pwhash_scryptsalsa208sha256_str_verify(str, passwd, passwdlen);
  }

  public static int crypto_shorthash(byte[] out, byte[] in, long inlen, byte[] k) {
    return SodiumJNI.crypto_shorthash(out, in, inlen, k);
  }

  public static int crypto_generichash(byte[] out, int outlen, byte[] in, long inlen, byte[] key, int keylen) {
    return SodiumJNI.crypto_generichash(out, outlen, in, inlen, key, keylen);
  }

}
